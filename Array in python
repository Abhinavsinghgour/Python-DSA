import array as arr

a = arr.array('i',[1,3,4,5,6])
print(a)
for i in range(0,len(a)):
    print(a[i], end=" ")
print()
print(a[2])


x = list(range(1,100,2))
array_1=arr.array('i',x)
print()
print(len(array_1))
# insert element
array_1.insert(0,50) #insert(index,value)

# append element
array_1.append(999)

for i in range(0,len(array_1)):
    print(array_1[i],end=" ")

print()
print(len(array_1))


# /////////////
# Deleting an element in an array
import array as arr
array = arr.array('i',[1,2,3,4,5,6])
for i in range(0,len(array)):
    print(array[i],end=" ")

array.pop(2)#delete element 3
print()
for i in range(0,len(array)):
    print(array[i],end=" ")



# Merge_sort
# Merge Sort is an efficient sorting algorithm with O(nlogn) running time.
def merge_sort(arr):
    if len(arr) > 1:
        left_arr = arr[:len(arr) // 2]
        right_arr = arr[len(arr) // 2:]

        # Recursion
        merge_sort(left_arr)
        merge_sort(right_arr)

        # Merge
        i = j = k = 0
        while i < len(left_arr) and j < len(right_arr):
            if left_arr[i] < right_arr[j]:
                arr[k] = left_arr[i]
                i += 1
            else:
                arr[k] = right_arr[j]
                j += 1
            k += 1  # âœ… Moved outside of the if-else block

        while i < len(left_arr):
            arr[k] = left_arr[i]
            i += 1
            k += 1

        while j < len(right_arr):
            arr[k] = right_arr[j]
            j += 1
            k += 1

arr = [2, 3, 5, 1, 7, 4, 4, 4, 2, 6, 8]
merge_sort(arr)
print(arr)


def quick_sort(arr):
  if len(arr)<=1:
    return arr
  else:
    pivot = arr.pop()
  
  item_greater=[]
  item_lower=[]
  
  for item in arr:
      if item > pivot:
          item_greater.append(item)
    
      else:
          item_lower.append(item)

  return quick_sort(item_lower) + [pivot] + quick_sort(item_greater)

print(quick_sort([3,4,5,3,7,8,3,6,4,1,2]))


# Quick Sort
def quicksort(arr,left,right):
    if left<right:
        partition_pos=partition(arr,left,right)
        quicksort(arr,left,partition_pos - 1)
        quicksort(arr,partition_pos +1,right)

def partition(arr,left,right):
    i =left
    j=right-1
    pivot=arr[right]

    while i<j:
        while i<right and arr[i]<pivot:
            i+=1
        while j>left and arr[j] >=pivot:
            j -=1
        if i<j:
            arr[i],arr[j]=arr[j],arr[i]

    if arr[i]>pivot:
        arr[i],arr[right]=arr[right],arr[i]

    return i

arr = [22,11,88,55,77,33,44]
quicksort(arr,0,len(arr)-1)
print(arr)





class BST:
    def __init__(self,key):
        self.key=key
        self.lchild=None
        self.rchild=None
    
    def insert(self,data):
        if self.key is None:
            self.key=data
            return
        if self.key==data:
            return
        if self.key>data:
            if self.lchild:
                self.lchild.insert(data) #Recursion
            else:
                self.lchild=BST(data)
        else:
            if self.rchild:
                self.rchild.insert(data)
            else:
                self.rchild=BST(data)


list1=[4,7,8,4,7,9,3,1,0,5]
root=BST(20)

for i in list1:
    root.insert(i)





from collections import Counter


def top_K_freq(arr,k):
    freq=Counter(arr)
    q=freq.most_common(k)
    result=[]
    for item,count in q:
      result.append(item)
    return result

print(top_K_freq([3,4,2,4,5,2,3,4,4,3],2))

